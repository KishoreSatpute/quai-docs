"use strict";(self.webpackChunkquai_docs=self.webpackChunkquai_docs||[]).push([[5211],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},m=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),m=a,h=p["".concat(l,".").concat(m)]||p[m]||u[m]||o;return n?i.createElement(h,r(r({ref:t},d),{},{components:n})):i.createElement(h,r({ref:t},d))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:a,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}m.displayName="MDXCreateElement"},5165:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var i=n(7462),a=(n(7294),n(3905));const o={title:"Opcode Additions",description:"Specification and implementation of Quai specific opcodes.",slug:"/opcode-additions",sidebar_position:1},r="Opcode Additions",s={unversionedId:"develop/smart-contracts/opcode-additions",id:"develop/smart-contracts/opcode-additions",title:"Opcode Additions",description:"Specification and implementation of Quai specific opcodes.",source:"@site/docs/develop/smart-contracts/opcode-additions.md",sourceDirName:"develop/smart-contracts",slug:"/opcode-additions",permalink:"/opcode-additions",draft:!1,editUrl:"https://github.com/dominant-strategies/quai-docs/tree/main/docs/develop/smart-contracts/opcode-additions.md",tags:[],version:"current",lastUpdatedBy:"Juuddi",lastUpdatedAt:1691613047,formattedLastUpdatedAt:"Aug 9, 2023",sidebarPosition:1,frontMatter:{title:"Opcode Additions",description:"Specification and implementation of Quai specific opcodes.",slug:"/opcode-additions",sidebar_position:1},sidebar:"developSidebar",previous:{title:"Smart Contracts",permalink:"/category/smart-contracts"},next:{title:"Languages",permalink:"/languages"}},l={},c=[{value:"What Are EVM Opcodes?",id:"what-are-evm-opcodes",level:2},{value:"Quai Specific Opcodes",id:"quai-specific-opcodes",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Inline Assembly",id:"inline-assembly",level:3},{value:"Examples",id:"examples",level:2},{value:"isaddrinternal",id:"isaddrinternal",level:3},{value:"etx",id:"etx",level:3},{value:"Conclusion",id:"conclusion",level:2}],d={toc:c},p="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"opcode-additions"},"Opcode Additions"),(0,a.kt)("h2",{id:"what-are-evm-opcodes"},"What Are EVM Opcodes?"),(0,a.kt)("p",null,"Opcodes are the individual low-level instructions that make up a smart contract on the Ethereum Virtual Machine (EVM). Each opcode corresponds to a specific operation that the EVM can perform, such as adding or comparing values in memory, or interacting with the blockchain. Opcodes are executed one at a time in the order they appear in a contract's bytecode. The set of opcodes available on the EVM is fixed and limited, but they provide a powerful set of building blocks for creating complex smart contracts."),(0,a.kt)("h2",{id:"quai-specific-opcodes"},"Quai Specific Opcodes"),(0,a.kt)("p",null,"Quai Network's implementation of the EVM introduces two new opcodes for developers to utilize. The new opcodes are as follows:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"isaddrinternal")," - Checks if provided address is within smart contract's context"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"etx")," - Emits an external transaction from the smart contract")),(0,a.kt)("p",null,"Each of these opcodes serve a very specific purpose within Quai Network's VM. isaddrinternal allows smart contracts to determine whether a contract interaction can occur entirely within a single context or whether an ETX needs to occur. Based on the boolean response from isaddrinternal, a smart contract can continue on as normal with a local interaction, or can emit an ETX using the etx opcode."),(0,a.kt)("h2",{id:"implementation"},"Implementation"),(0,a.kt)("h3",{id:"inline-assembly"},"Inline Assembly"),(0,a.kt)("p",null,"Solidity does not currently have native compiler support for Quai's additional opcodes that provide cross-chain functionality, but it does have support for ",(0,a.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/latest/assembly.html"},"inline assembly usage"),"."),(0,a.kt)("p",null,"Inline assembly is typically implemented by developers for more fine-grained control over your contract. In the context of Quai, we can use it to directly call opcodes inside of contracts via Yul and Assembly. This allows us to maintain the same general structure as traditional Solidity based contract while implementing simple assembly to provide functionality for Quai specific utilities."),(0,a.kt)("p",null,"Inline assembly within Solidity is generally straightforward as you can access your contract's variables via normal methods and insert directly into assembly. The syntax for inserting assembly into your contract is as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},"function doSomethingWithAssembly() {\n    assembly {...}\n}\n")),(0,a.kt)("p",null,"More information on case specific syntax, usage and conventions can be found on the Solidity ",(0,a.kt)("a",{parentName:"p",href:"https://docs.soliditylang.org/en/latest/assembly.html"},"inline assembly page"),"."),(0,a.kt)("h2",{id:"examples"},"Examples"),(0,a.kt)("h3",{id:"isaddrinternal"},"isaddrinternal"),(0,a.kt)("p",null,"As mentioned above, the ",(0,a.kt)("inlineCode",{parentName:"p"},"isaddrinternal")," opcode is used to verify that an address is within a specific chain's scope. It is most often used in contracts to determine whether the contract should initiate a traditional in-scope transaction or opt for an external transaction."),(0,a.kt)("p",null,"Below is a simple implementation of the opcode in a ERC20 smart contract:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'function transfer(address to, uint256 amount) public payable  returns (bool) {\n        bool isInternal;\n        assembly {\n            isInternal := isaddrinternal(to)  // This opcode returns true if an address is internal\n        }\n        require(isInternal, "Address is external. Use cross-chain transfer function.");\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"transfer")," function handles token transfers between two wallets. Inline assembly and the ",(0,a.kt)("inlineCode",{parentName:"p"},"isaddrinternal")," opcode are used to verify that an address is internal."),(0,a.kt)("p",null,"If the check returns true, the function executes the transfer normally. If the check returns false, the transfer is not executed and the user is directed to utilize another function to complete a cross-chain transfer."),(0,a.kt)("h3",{id:"etx"},"etx"),(0,a.kt)("p",null,"External transactions, also called a cross-chain transfers, can be initiated by smart contract via the ",(0,a.kt)("inlineCode",{parentName:"p"},"etx")," opcode."),(0,a.kt)("p",null,"A basic example of ",(0,a.kt)("inlineCode",{parentName:"p"},"etx")," implementation in the same ERC20 contract from the isaddrinternal can be seen below. The ",(0,a.kt)("inlineCode",{parentName:"p"},"crossChainTransfer")," function should be called if the check inside of transfer returns false."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-solidity"},'/**\n* This function sends tokens to an address on another chain by creating an external transaction (ETX).\n* This function uses opETX which constructs an external transaction and adds it to the block.\n* The ETX will make its way over to the destination and automatically execute when the given base fee is correct.\n* `to` must be an address on a different chain. The chain of a given address is determined by the first byte of the address.\n* gasLimit, minerTip and basefee are for executing the transaction on the destination chain. Choose these carefully.\n* The base fee and miner tip are in Wei and may not be the same as they are on your current chain.\n* If the base fee or miner tip are too low, the ETX will wait in the destination chain until they are high enough to be added in a block.\n* You must send a value with the function call equal to the following amount: (baseFee + minerTip) * gasLimit\n*/\nfunction crossChainTransfer(address to, uint256 amount, uint256 gasLimit, uint256 minerTip, uint256 baseFee) public payable {\n        bool isInternal;\n        assembly {\n            isInternal := isaddrinternal(to) // This opcode returns true if an address is internal\n        }\n        require(!isInternal, "Address is not external");\n\n        _burn(msg.sender, amount);\n        address toAddr = ApprovedAddresses[getAddressLocation(to)];\n        uint totalGas = (baseFee + minerTip) * gasLimit;\n        require(msg.value  >= totalGas, string(abi.encodePacked("Not enough gas sent, need at least ", uint2str(totalGas), " wei")));\n        bytes memory encoded = abi.encodeWithSignature("incomingTransfer(address,uint256)", to, amount);\n        bool success;                                       // this is not used. opETX only returns false if there was an error in creating the ETX, not executing it.\n        assembly {\n            success := etx(\n                0,                                          // temp variable, can be anything (unused)\n                toAddr,                                     // address to send to\n                0,                                          // amount to send in wei\n                gasLimit,                                     // gas limit (entire gas limit will be consumed and sent to destination)\n                minerTip,                                     // miner tip in wei\n                baseFee,                                      // base fee in wei\n                add(encoded, 0x20),                                          // input offset in memory (the first 32 byte number is just the size of the array)\n                mload(encoded),                                          // input size in memory (loading the first number gives the size)\n                0,                                          // accesslist offset in memory\n                0                                           // accesslist size in memory\n            )\n        }\n        emit ExternalTransfer(msg.sender, to, amount);\n}\n')),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"crossChainTransfer")," utilizes an initial check to ensure that the destination is address is outside of the current context scope. The contract then executes in this fashion:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Burns the provided ",(0,a.kt)("inlineCode",{parentName:"li"},"amount")," of tokens on the origin chain."),(0,a.kt)("li",{parentName:"ol"},"Sets the ",(0,a.kt)("inlineCode",{parentName:"li"},"toAddr")," to the public key of a sister contract on the destination chain."),(0,a.kt)("li",{parentName:"ol"},"Calculates the ",(0,a.kt)("inlineCode",{parentName:"li"},"totalGas")," provided by the user ",(0,a.kt)("em",{parentName:"li"},"and")," checks that the provided gas is sufficient to execute the transaction."),(0,a.kt)("li",{parentName:"ol"},"Encodes the transaction data being sent to the destination chain into ",(0,a.kt)("inlineCode",{parentName:"li"},"encoded"),"."),(0,a.kt)("li",{parentName:"ol"},"Constructs the external transaction using the ",(0,a.kt)("inlineCode",{parentName:"li"},"etx")," opcode via inline assembly."),(0,a.kt)("li",{parentName:"ol"},"Emits the transaction from the contract to be mined on the origin chain and routed to the destination chain.")),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"isaddrinternal")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"etx")," opcodes provide key cross-chain functionality to smart contracts deployed on Quai Network. They provide the basis for contracts in different contexts to communicate and interact with each other in a trustless fashion and allow developers to create multi-chain applications that span the entire network."))}u.isMDXComponent=!0}}]);